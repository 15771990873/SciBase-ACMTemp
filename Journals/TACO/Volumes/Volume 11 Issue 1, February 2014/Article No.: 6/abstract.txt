Trace-based Just-In-Time (JIT) compilation generates machine code for frequently executed paths (so-called traces) instead of whole methods. While this has several advantages, it complicates invocation of compiled traces as well as exception handling, so that previous trace-based compilers limited the way in which traces could be invoked.We present a significantly enhanced trace-based compiler where arbitrary transitions between interpreted and compiled traces are possible. For that, we introduce suitable trace calling conventions and extend exception handling to work both within traces and across trace boundaries. Furthermore, we use the recorded trace information for optimizations and combine the tracing ideas with ideas from partial-method compilation to avoid code bloat.An extensive evaluation with the benchmark suites DaCapo 9.12 Bach and SPECjvm2008 shows that our trace-based compiler achieves up to 59&percnt; higher peak performance than the method-based Java HotSpot client compiler. On a few benchmarks, our fairly simple trace-based compiler shows a higher peak performance than the Java HotSpot server compiler, which is one of today's best optimizing JIT compilers for Java.