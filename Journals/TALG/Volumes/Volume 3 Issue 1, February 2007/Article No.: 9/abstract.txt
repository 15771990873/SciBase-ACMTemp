Query optimization that involves expensive predicates has received considerable attention in the database community. Typically, the output to a database query is a set of tuples that satisfy certain conditions, and, with expensive predicates, these conditions may be computationally costly to verify. In the simplest case, when the query looks for the set of tuples that simultaneously satisfykexpensive predicates, the problem reduces to ordering the evaluation of the predicates so as to minimize the time to output the set of tuples comprising the answer to the query. We study different cases of the problem: thesequential case, in which a single processor is available to evaluate the predicates, and thedistributed case, in which there arekprocessors available, each dedicated to a different attribute (column) of the database, and there is no communication cost between the processors.For the sequential case, we give a simple and fast deterministick-approximation algorithm, and prove thatkis the best possible approximation ratio for a deterministic algorithm, even if exponential time algorithms are allowed. We also propose a randomized, polynomial time algorithm with expected approximation ratio 1 &plus; &sqrt;2/2 &ap; 1.707 fork&equals; 2, and prove that 3/2 is the best possible expected approximation ratio for randomized algorithms. We also show that given 0 ≤ &epsiv; ≤ 1, no randomized algorithm achieves approximation ratio smaller than 1 &plus; &epsiv; with probability larger than (1 &plus; &epsiv;)/2.For the distributed case, we consider two different models: thepreemptive model, in which a processor is allowed to interrupt the evaluation of a predicate, and thenonpreemptive model, in which the evaluation of a predicate must be completed once started. We show thatkis the best possible approximation ratio for a deterministic algorithm, even if exponential time algorithms are allowed. For the preemptive model, we introduce a polynomial timek-approximation algorithm. For the nonpreemptive model, we introduce a polynomial timeO(klog2k)-approximation algorithm.