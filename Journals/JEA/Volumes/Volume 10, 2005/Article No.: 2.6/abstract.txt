Bit-parallelism permits executing several operations simultaneously over a set of bits or numbers stored in a single computer word. This technique permits searching for the approximate occurrences of a pattern of lengthmin a text of lengthnin timeO(⌈m/w⌉n), wherewis the number of bits in the computer word. Although this is asymptotically the optimal bit-parallel speedup over the basicO(mn) time algorithm, it wastes bit-parallelism's power in the common case wheremis much smaller thanw, sincew−mbits in the computer words are unused. In this paper, we explore different ways to increase the bit-parallelism when the search pattern is short. First, we show how multiple patterns can be packed into a single computer word so as to search for all them simultaneously. Instead of spendingO(rn) time to search forrpatterns of lengthm≤w/2, we needO(⌈rm/w⌉n) time. Second, we show how the mechanism permits boosting the search for a single pattern of lengthm≤w/2, which can be searched for inO(⌈n/⌊w/m⌋⌉) bit-parallel steps instead ofO(n). Third, we show how to extend these algorithms so that the time bounds essentially depend onkinstead ofm, wherekis the maximum number of differences permitted. Finally, we show how the ideas can be applied to other problems such as multiple exact string matching and one-against-all computation of edit distance and longest common subsequences. Our experimental results show that the new algorithms work well in practice, obtaining significant speedups over the best existing alternatives, especially on short patterns and moderate number of differences allowed. This work fills an important gap in the field, where little work has focused on very short patterns.