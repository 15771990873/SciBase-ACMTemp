We tackle the problem of counting the numberqkofk-cliques in large-scale graphs, for any constantk≥ 3. Clique counting is essential in a variety of applications, including social network analysis. Our algorithms make it possible to computeqkfor several real-world graphs and shed light on its growth rate as a function ofk. Even for small values ofk, the numberqkofk-cliques can be in the order of tens or hundreds of trillions. Askincreases, different graph instances show different behaviors: while on some graphsqk+ 1<qk, on other benchmarksqk+ 1»qk, up to two orders of magnitude in our observations. Graphs with steep clique growth rates represent particularly tough instances in practice.Due to the computationally intensive nature of the clique counting problem, we settle for parallel solutions in the MapReduce framework, which has become in the last few years a de facto standard for batch processing of massive datasets. We give both theoretical and experimental contributions.On the theory side, we design the first exact scalable algorithm for counting (and listing)k-cliques in MapReduce. Our algorithm usesO(m3/2) total space andO(mk/2) work, wheremis the number of graph edges. This matches the best-known bounds for triangle listing whenk&equals; 3 and is work optimal in the worst case for anyk, while keeping the communication cost independent ofk. We also design sampling-based estimators that can dramatically reduce the running time and space requirements of the exact approach, while providing very accurate solutions with high probability.We then assess the effectiveness of different clique counting approaches through an extensive experimental analysis over the Amazon EC2 platform, considering both our algorithms and their state-of-the-art competitors. The experimental results clearly highlight the algorithm of choice in different scenarios and prove our exact approach to be the most effective when the number ofk-cliques is large, gracefully scaling to nontrivial values ofkeven on clusters of small/medium size. Our approximation algorithms achieve extremely accurate estimates and large speedups, especially on the toughest instances for the exact algorithms.