We investigate architechural schemes, generalizing that of existing graphics engines, supporting fast rendering of traingle meshes. A mesh defined onnvertices is rendered by sending vertices down a graphics pipeline, after which they are pushed on a stack to by popped when no longer needed. Only individual traingles whose vertices are present in the stack may be rendered. The storage cost of the mesh rendering is the size of the stack required to store mesh vertices during the rendering process. This may be significantly less thann. The time cost of the mesh rendering is the number of vertices sent down the graphics pipeline. If a large enough stack is available, it usuffices to send each vertix once. If only a small stack is available, some       vertices may have to be sent more than once, so a time/space tradeoff exists. With our architecture, stack of sizeOnis sufficient to render any triangle mesh defined onnvertices, such that each vertex is sent only once through the graphics pipeline (time cost =n). We provide an algorithm that generates an appropriate “rendering sequence” of commands for any given mesh. Moreover, we show that no algorithm can do better, that is,Wnis a lower bound. Somen-vertex meshes may be rendered using a stack whose size is    significantly less thanOn. An algorithm generating   a minimum-time rendering sequence rquiring the minimum stack size is an open  question. We provide an approximation: if it is theoretically possible to render a triangle mesh is minimum time with a stack of sizeS, our algoithm generates a minimum-time rendering sequence requiring a stack of size no larger than 2Slog3/2n. If only a stack of sizekis available, we provide an algorithm generating a rendering sequence requiring a stack of size no larger thank, such that at mostn(1+c/k)vertices must be sent through the pipeline, for some constantc.