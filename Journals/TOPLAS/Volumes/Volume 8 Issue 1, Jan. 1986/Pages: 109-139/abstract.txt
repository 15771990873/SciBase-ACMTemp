In Part 1 of this paper [5], we presented a scheme whereby a compiler could propagate demands through programs in a powerful stream language L. A data-driven evaluation of the transformed program performed exactly the same computation as a demand-driven evaluation of the original program. In this paper we explore a different transformation, which trades the complexity of demand propagation for aboundedamount of extra computation on some data lines.