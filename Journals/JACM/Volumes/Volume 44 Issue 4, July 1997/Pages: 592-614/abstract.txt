The problem of implementing a shared object of one type from shared objects of other types has been extensively researched. Recent focus has mostly been onwait-free implementations, which permit every process to complete its operations on implemented objects, regardless of the speeds of other processes. It is known that shared objects of different types have differing abilities to support wait-free implementations. It is therefore natural to want to arrange types in a hierarchy that reflects their relative abilities to support wait-free implementations. In this paper, we formally define robustness and other desirable properties of hierarchies. Roughly speaking, a hierarchy is robust if each type is “stronger” than any combination of lower level types. We study two specific hierarchies: one, that we callhrmin which the level of a type is based on the ability of anunboundednumber of objects of that type, and another hierarchy, that we callhr1, in which a type's level is based on the ability of afixednumber of objects of that type. We prove that resource bounded hierarchies, such ashr1and its variants, are not robust. We also establish the unique importance ofhrm: every nontrivial robust hierarchy, if one exists, is necessarily a “coarsening” ofhrm.