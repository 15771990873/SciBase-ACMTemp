Three ACM symposia on Principles of Programming Languages, jointly sponsored by SIGACT and SIGPLAN, have now been held. The first symposium was in October 1973, the second in January 1975, and the third the following year. It is now planned that the symposia be held annually. The fourth symposium is scheduled for January 17-19, 1977, in Los Angeles.Four of the twenty papers presented at the third symposium have been selected for publication in this special section.1Each paper was refereed in the customary fashion and each of the papers appearing here is a revised or extended version of the original paper or extended abstract included in the Conference Record. The papers address a variety of topics, yet they have in common a blend of both theoretical and pragmatic considerations.Two of the papers discuss techniques for program transformations. (Indeed, program transformation was an important theme at the symposium.)Baker presents an algorithm for transforming a program in which the flow of control may not be represented by structured-programming-style syntax into a computationally equivalent program which is more readable because the iterative and conditional structure is explicit. An implementation of the technique is described in which Fortran programs are transformed to a structured Fortran dialect.The paper by Loveman discusses the transformation of programs to equivalent programs in the same language which require less running time and/or less space. He illustrates a number of these transformations and describes several programming systems in which the source-to-source techniques have been used. He also argues that appropriate source-to-source transformations can be used to transform a program to a form in which a straightforward code generator could produce the sort of code now generated by conventional optimizing compilers. Such a technique would simplify the code generation phase of a compiler and would provide the programmer with a source-level description of the optimized program.A different aspect of code generation is the topic of the paper by Aho, Johnson, and Ullman. They study the problem of generating good machine code for so-called straight line source code which contains common subexpressions (i.e. multiple occurrences of the same variables or expressions). They show that under a variety of assumptions, the generation of optimal code sequences is computationally difficult in a certain sense. An analysis of some heuristics for code generation is given which offers insight into the reasons for the complexity and some approaches to generating reasonable code sequences at an acceptable cost.Unlike the other papers, all of which, in some sense, give methods for creating programs from other programs, the paper by Summers investigates methods for creating programs from examples of their behavior. An implementation is described in which, by exploiting the structure embodied in S-expressions, programs in a subset of LISP are synthesized from pairs of S-expressions.In order to achieve timely publication of a special section such as this one, it was necessary to set deadlines for each stage in the process. The cooperation of the authors, the referees, and the editors in meeting these deadlines is gratefully acknowledged.