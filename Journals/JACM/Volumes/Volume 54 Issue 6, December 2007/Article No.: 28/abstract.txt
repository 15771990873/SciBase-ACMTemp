We present a general deterministic linear space reduction from priority queues to sorting implying that if we can sort up tonkeys inS(n) time per key, then there is a priority queue supporting delete and insert inO(S(n)) time and find-min in constant time. Conversely, a priority queue can trivially be used for sorting: first insert all keys to be sorted, then extract them in sorted order by repeatedly deleting the minimum. Asymptotically, this settles the complexity of priority queues in terms of that of sorting.Previously, at SODA'96, such a result was presented by the author for the special case of monotone priority queues where the minimum is not allowed to decrease.Besides nailing down the complexity of priority queues to that of sorting, and vice versa, our result yields several improved bounds for linear space integer priority queues with find-min in constant time:Deterministically. We getO(log logn) update time using a sorting algorithm of Han from STOC'02. This improves theO((log logn)(log log logn)) update time of Han from SODA'01.Randomized. We getO(&sqrt;log logn) expected update time using a randomized sorting algorithm of Han and Thorup from FOCS'02. This improves theO(log logn) expected update time of Thorup from SODA'96.Deterministically in AC0(without multiplication). For any &epsiv; > 0, we getO((log logn)1&plus;&epsiv;) update time using an AC0sorting algorithm of Han and Thorup from FOCS'02. This improves theO((log logn)2) update time of Thorup from SODA'98.Randomized in AC0. We getO(log logn) expected update time using a randomized AC0sorting algorithm of Thorup from SODA'97. This improves theO((log logn)1&plus;&epsiv;) expected update time of Thorup also from SODA'97.The above bounds assume that each integer is stored in a single word and that word operations take unit time as in the word RAM.