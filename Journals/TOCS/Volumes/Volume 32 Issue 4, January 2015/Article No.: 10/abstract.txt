What opportunities for multicore scalability are latent in software interfaces, such as system call APIs&quest; Can scalability challenges and opportunities be identified even before any implementation exists, simply by considering interface specifications&quest; To answer these questions, we introduce the scalable commutativity rule:whenever interface operations commute, they can be implemented in a way that scales.This rule is useful throughout the development process for scalable multicore software, from the interface design through implementation, testing, and evaluation.This article formalizes the scalable commutativity rule. This requires defining a novel form of commutativity,SIM commutativity, that lets the rule apply even to complex and highly stateful software interfaces.We also introduce a suite of software development tools based on the rule. OurCommutertool accepts high-level interface models, generates tests of interface operations that commute and hence could scale, and uses these tests to systematically evaluate the scalability of implementations. We applyCommuterto a model of 18 POSIX file and virtual memory system operations. Using the resulting 26,238 scalability tests,Commuterhighlights Linux kernel problems previously observed to limit application scalability and identifies previously unknown bottlenecks that may be triggered by future workloads or hardware.Finally, we apply the scalable commutativity rule andCommuterto the design and implementation sv6, a new POSIX-like operating system. sv6’s novel file and virtual memory system designs enable it to scale for 99&percnt; of the tests generated byCommuter. These results translate to linear scalability on an 80-core x86 machine for applications built on sv6’s commutative operations.