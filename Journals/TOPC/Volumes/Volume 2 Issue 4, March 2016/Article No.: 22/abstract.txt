In fork-join parallelism, a sequential program is split into a directed acyclic graph of tasks linked by directed dependency edges, and the tasks are executed, possibly in parallel, in an order consistent with their dependencies. A popular and effective way to extend fork-join parallelism is to allow threads to create futures. A thread creates a future to hold the results of a computation, which may or may not be executed in parallel. That result is returned when some thread touches that future, blocking if necessary until the result is ready.Recent research has shown that although futures can, of course, enhance parallelism in a structured way, they can have a deleterious effect on cache locality. In the worst case, futures can incur Ω(PT∞+tT∞) deviations, which implies Ω (CPT&infty;+CtT&infty;) additional cache misses, whereCis the number of cache lines,Pis the number of processors,tis the number of touches, andT∞is the computation span. Since cache locality has a large impact on software performance on modern multicores, this result is troubling.In this article, we show that if futures are used in a simple, disciplined way, then the situation is much better: if each future is touched only once, either by the thread that created it or by a later descendant of the thread that created it, then parallel executions with work stealing can incur at mostO(CPT2&infty;) additional cache misses—a substantial improvement. This structured use of futures is characteristic of many (but not all) parallel applications.